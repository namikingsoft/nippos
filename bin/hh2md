#!/bin/sh -eu

opt=$(getopt -o "" -l token:,domain:,userid:,channelid:,channeltype:,date: -- "$@")
eval set -- "$opt"
until [ "$1" = "--" ]; do
  case $1 in
    --token) slack_token="$2" ;;
    --domain) slack_domain="$2" ;;
    --userid) slack_user_id="$2" ;;
    --channelid) slack_channel_id="$2" ;;
    --channeltype) slack_channel_type="$2" ;;
    --date) slack_date="$2" ;;
  esac
  shift
done

slack_token="${slack_token:-$SLACK_TOKEN}"
slack_domain="${slack_domain:-$SLACK_DOMAIN}"
slack_user_id="${slack_user_id:-$SLACK_USER_ID}"
slack_channel_id="${slack_channel_id:-$SLACK_CHANNEL_ID}"
slack_channel_type="${slack_channel_type:-${SLACK_CHANNEL_TYPE:-channels}}"
slack_date="${slack_date:-${SLACK_DATE:-undef}}"

start_ts=$(
  if [ "undef" = "$slack_date" ]
    then date -d "$(date "+%Y-%m-%d") 00:00:00" "+%s"
    else date -d "${slack_date} 00:00:00" "+%s"
  fi
)
end_ts=$(
  if [ "undef" = "$slack_date" ]
    then date -d "$(date "+%Y-%m-%d") 23:59:59" "+%s"
    else date -d "${slack_date} 23:59:59" "+%s"
  fi
)

[ -p /dev/stdin ] && paragraph_json=$(cat --)
paragraph_json="${paragraph_json:-$PARAGRAPH_JSON}"

history_json_base64=$(
  curl --silent \
    -X GET "https://slack.com/api/${slack_channel_type}.history?token=${slack_token}&channel=${slack_channel_id}&count=1000&oldest=${start_ts}&latest=${end_ts}" \
  | jq -r '. | @base64'
)

paragraph() {
  type="$1"
  headline="$2"
  exfilter="$3"
  echo "## ${headline}"
  echo
  filter_loop=$(
    echo "$history_json_base64" \
    | base64 --decode \
    | jq -r "
      [
        .messages
        | reverse
        | .[]
        | ${exfilter}
        | select((.text != null) and (.text != \"\"))
      ]
      | unique_by(.ts)
      | .[]
      | @base64
    "
  )
  for row in $filter_loop; do
    ts=$(echo "$row" | base64 --decode | jq -r .ts)
    timestamp=$(echo "$ts" | sed -E 's|\..*$||')
    timelabel=$(date --date "@${timestamp}" "+%H:%M:%S")
    permalink="https://${slack_domain}/messages/${slack_channel_id}/p$(echo "$ts" | sed -E 's|\.||')"
    text=$(
      echo "$row" | base64 --decode \
      | jq -r .text \
      | sed -E 's/^<(https?:[^>]+\.)(png|gif)>$/![Picture](\1\2)/g' \
      | sed -E 's|<(https?:[^>]+)>|\[\1\]\(\1\)|g' \
      | sed -E 's|<([^:]+:[^>]+)>|\1|g' \
      | sed -E 's|&lt;|<|g' | sed -E 's|&gt;|>|g' | sed -E 's|&amp;|&|g' \
      | perl -0pe 's|(```\n[\s\S]*?\n```)|\n\1|m'
    )
    if [ "$type" = "timeline" ]; then
      echo "<a href=\"${permalink}\" class=\"timeline\">${timelabel}</a>"
      echo "$text"
      echo
    else
      echo "$text"
    fi
  done
  echo
}

for row in $(echo "$paragraph_json" | jq -r ".[] | @base64"); do
  json=$(echo "$row" | base64 --decode)
  type=$(echo "$json" | jq -r .type)
  title=$(echo "$json" | jq -r .title)
  reaction=$(echo "$json" | jq -r .reaction)
  filter="
    (.reactions != null) and
    (.reactions[].name == \"${reaction}\") and
    (.reactions[].users[] == \"${slack_user_id}\")
  "
  paragraph "$type" "$title" "select(${filter})"
done

echo "<details><summary>**クリックで生作業ログを展開**</summary><div>"
paragraph "timeline" "本日の生ログ" "select(.user != null)"
echo "</div></details>"

cat << EOS

<script>
Array.prototype.forEach.call(
  document.querySelectorAll('a.timeline'),
  function(elm) {
    elm.style.position = 'absolute';
    elm.style.top = 0;
    elm.style.left = '-98px';
    elm.innerText = elm.innerText.replace(/:\d\d/, '');
    var initParagraphRec = function (pElm) {
      pElm.style.position = 'relative';
      pElm.style.marginLeft = '100px';
      pElm.style.marginTop = '0';
      pElm.style.marginBottom = '0';
      pElm.style.paddingTop = '0';
      pElm.style.paddingBottom = '1.5em';
      var line = document.createElement('div');
      line.style.position = 'absolute';
      line.style.width = '2px';
      line.style.top = '0';
      line.style.bottom = '0';
      line.style.left = '-29px';
      line.style.backgroundColor = '#eaeaea';
      pElm.appendChild(line);
      if (pElm.querySelector('a.timeline')) {
        var circle = document.createElement('div');
        var body = pElm.innerText;
        var iconElm = document.createElement('i');
        iconElm.style.backgroundColor = '#fff';
        iconElm.classList.add('fa');
        circle.style.color = '#555';
        if (body.indexOf('https://github.com/') > -1) {
          iconElm.classList.add('fa-github');
        } else if (/https:\/\/[^.]+\.slack\.com\//.test(body)) {
          iconElm.classList.add('fa-slack');
        } else if (/https:\/\/circleci\.com\//.test(body)) {
          iconElm.classList.add('fa-comments');
          circle.style.color = '#eaeaea';
        } else if (/https?:\/\//.test(body)) {
          iconElm.classList.add('fa-info-circle');
        } else {
          iconElm.classList.add('fa-comments');
          circle.style.color = '#eaeaea';
        }
        circle.style.position = 'absolute';
        circle.style.padding = '0';
        circle.style.fontSize = '1.5em';
        circle.style.marginLeft = '-32px';
        circle.style.top = '-0.25em';
        circle.style.left = '-0.25em';
        circle.appendChild(iconElm);
        pElm.appendChild(circle);
      }
      var nextElm = pElm.nextElementSibling;
      if (nextElm && nextElm.querySelector && /^(p|div|blockquote)$/i.test(nextElm.tagName) && !nextElm.querySelector('a.timeline')) {
        nextElm.style.margin = '0';
        var wrapElm = document.createElement('p');
        wrapElm.appendChild(nextElm.cloneNode(true));
        nextElm.parentNode.replaceChild(wrapElm, nextElm);
        initParagraphRec(wrapElm);
      }
    };
    initParagraphRec(elm.parentNode);
  }
);
Array.prototype.forEach.call(
  document.querySelectorAll('a.timeline + br'),
  function(elm) {
    elm.remove();
  }
);
</script>
EOS
